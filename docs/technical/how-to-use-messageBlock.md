# messageBlock.ts User Guide

This file defines a Redux Slice for managing all `MessageBlock` entities in the
application. It uses Redux Toolkit's `createSlice` and `createEntityAdapter` to
efficiently handle normalized state, and provides a series of actions and
selectors for interacting with message block data.

## Core Objectives

- **State Management**: Centralized management of all `MessageBlock` states.
  `MessageBlock` represents different content units in messages (such as text,
  code, images, citations, etc.).
- **Normalization**: Using `createEntityAdapter` to store `MessageBlock` data in
  a normalized structure (`{ ids: [], entities: {} }`), which helps improve
  performance and simplify update logic.
- **Predictability**: Providing clear actions to modify state and selectors to
  safely access state.

## Key Concepts

- **Slice (`createSlice`)**: Redux Toolkit's core API for creating Redux modules
  that include reducer logic, action creators, and initial state.
- **Entity Adapter (`createEntityAdapter`)**: A tool provided by Redux Toolkit
  to simplify CRUD (Create, Read, Update, Delete) operations on normalized data.
  It automatically generates reducer functions and selectors.
- **Selectors**: Functions used to derive and compute data from the Redux store.
  Selectors can be memoized to improve performance.

## State Structure

The state structure of the `messageBlocks` slice defined by
`createEntityAdapter` is roughly as follows:

```typescript
{
  ids: string[]; // Ordered list of all MessageBlock IDs
  entities: { [id: string]: MessageBlock }; // Dictionary storing MessageBlock objects by ID
  loadingState: 'idle' | 'loading' | 'succeeded' | 'failed'; // (Optional) Other states, such as loading state
  error: string | null; // (Optional) Error message
}
```

## Actions

This slice exports the following actions (automatically generated by
`createSlice` and `createEntityAdapter` or customized):

- **`upsertOneBlock(payload: MessageBlock)`**:

  - Adds a new `MessageBlock` or updates an existing one. If the `id` in the
    payload already exists, it performs an update; otherwise, it inserts.

- **`upsertManyBlocks(payload: MessageBlock[])`**:

  - Adds or updates multiple `MessageBlock`s. Commonly used for batch loading
    data (e.g., loading all message blocks for a Topic).

- **`removeOneBlock(payload: string)`**:

  - Removes a single `MessageBlock` based on the provided `id` (payload).

- **`removeManyBlocks(payload: string[])`**:

  - Removes multiple `MessageBlock`s based on the provided array of `id`s
    (payload). Commonly used when deleting messages or clearing blocks related
    to a Topic.

- **`removeAllBlocks()`**:

  - Removes all `MessageBlock` entities from the state.

- **`updateOneBlock(payload: { id: string; changes: Partial<MessageBlock> })`**:

  - Updates an existing `MessageBlock`. The `payload` needs to include the
    block's `id` and a `changes` object containing the fields to be modified.

- **`setMessageBlocksLoading(payload: 'idle' | 'loading')`**:

  - (Custom) Sets the `loadingState` property.

- **`setMessageBlocksError(payload: string)`**:
  - (Custom) Sets `loadingState` to `'failed'` and records the error message.

**Usage Example (in Thunks or other Dispatch locations):**

```typescript
import {
  removeManyBlocks,
  updateOneBlock,
  upsertOneBlock,
} from "./messageBlock";
import store from "./store"; // Assuming this is your Redux store instance

// Add or update a block
const newBlock: MessageBlock = {
  /* ... block data ... */
};
store.dispatch(upsertOneBlock(newBlock));

// Update a block's content
store.dispatch(
  updateOneBlock({ id: blockId, changes: { content: "New content" } }),
);

// Delete multiple blocks
const blockIdsToRemove = ["id1", "id2"];
store.dispatch(removeManyBlocks(blockIdsToRemove));
```

## Selectors

This slice exports basic selectors generated by `createEntityAdapter` and
accessed through the `messageBlocksSelectors` object:

- **`messageBlocksSelectors.selectIds(state: RootState): string[]`**: Returns an
  array containing all block IDs.
- **`messageBlocksSelectors.selectEntities(state: RootState): { [id: string]: MessageBlock }`**:
  Returns a dictionary mapping block IDs to block objects.
- **`messageBlocksSelectors.selectAll(state: RootState): MessageBlock[]`**:
  Returns an array containing all block objects.
- **`messageBlocksSelectors.selectTotal(state: RootState): number`**: Returns
  the total number of blocks.
- **`messageBlocksSelectors.selectById(state: RootState, id: string): MessageBlock | undefined`**:
  Returns a single block object by ID, or `undefined` if not found.

**Additionally, a custom memoized selector is provided:**

- **`selectFormattedCitationsByBlockId(state: RootState, blockId: string | undefined): Citation[]`**:
  - Accepts a `blockId`.
  - If the block with that ID is of type `CITATION`, it extracts and formats the
    citation information it contains (from web searches, knowledge bases, etc.),
    deduplicates and renumbers them, and returns a `Citation[]` array for
    display in the UI.
  - If the block doesn't exist or is not of the matching type, it returns an
    empty array `[]`.
  - This selector encapsulates complex logic for handling different citation
    sources (Gemini, OpenAI, OpenRouter, Zhipu, etc.).

**Usage Example (in React components or with `useSelector`):**

```typescript
import { useSelector } from "react-redux";
import {
  messageBlocksSelectors,
  selectFormattedCitationsByBlockId,
} from "./messageBlock";
import type { RootState } from "./store";

// Get all blocks
const allBlocks = useSelector(messageBlocksSelectors.selectAll);

// Get a specific block by ID
const specificBlock = useSelector((state: RootState) =>
  messageBlocksSelectors.selectById(state, someBlockId)
);

// Get formatted citations for a specific citation block
const formattedCitations = useSelector((state: RootState) =>
  selectFormattedCitationsByBlockId(state, citationBlockId)
);

// Use citation data in a component
// {formattedCitations.map(citation => ...)}
```

## Integration

The `messageBlock.ts` slice typically works closely with Thunks in
`messageThunk.ts`. Thunks handle asynchronous logic (such as API calls, database
operations) and dispatch actions from the `messageBlock` slice to update the
state when needed. For example, when `messageThunk` receives a streaming
response, it dispatches `upsertOneBlock` or `updateOneBlock` to update the
corresponding `MessageBlock` in real-time. Similarly, a Thunk for deleting
messages would dispatch `removeManyBlocks`.

Understanding that `messageBlock.ts` is responsible for managing **the state
itself**, while `messageThunk.ts` handles **asynchronous processes that trigger
state changes**, is crucial for maintaining a clear application architecture.
